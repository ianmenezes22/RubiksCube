# -*- coding: utf-8 -*-
"""Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ofz-ZaiETUs6rMY9xL5j_mSGvJilHgBn
"""

class Location:
  lat=None
  lon=None
  
  def __init__(self, lat, lon):
    self.lat=lat
    self.lon=lon
    
  def __eq__(self, other) : 
        return self.__dict__ == other.__dict__

def inc_equator(cur_state):
  new_state=[]
  for i in cur_state:
      if i.lat==90:
        lat=90
        if i.lon==330:
          lon=0
        else:
          lon=i.lon+30
        temp=Location(lat,lon)
        new_state.append(temp)
      else:
        new_state.append(i)
  return new_state

def dec_equator(cur_state):
  new_state=[]
  for i in cur_state:
      if i.lat==90:
        lat=90
        if i.lon==0:
          lon=330
        else:
          lon=i.lon-30
        temp=Location(lat,lon)
        new_state.append(temp)
      else:
        new_state.append(i)
  return new_state

def inc_lon0_180(cur_state):
  new_state=[]
  for i in cur_state:   
        if i.lon==0:
          lon=0
          lat=i.lat+30
          if lat==180:
            lon=180
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lon==180:
          lon=180
          lat=i.lat-30
          if lat==0:
            lon=0
          temp=Location(lat,lon)
          new_state.append(temp)
        else:
          new_state.append(i)
  return new_state
            
def dec_lon0_180(cur_state):
  new_state=[]
  for i in cur_state:   
        if i.lon==0:
          lon=0
          if i.lat==0:
            lon=180
            lat=30
          else:
            lat=i.lat-30
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lon==180:
          lon=180
          if i.lat==180:
            lat=150
            lon=0
          else:
            lat=i.lat+30
          temp=Location(lat,lon)
          new_state.append(temp)
        else:
          new_state.append(i)
  return new_state
            
def inc_lon90_270(cur_state):
  new_state=[]
  for i in cur_state:   
        if i.lon==90:
          lon=90
          lat=i.lat+30
          if lat==180:
            lon=180
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lon==270:
          lon=270
          lat=i.lat-30
          if lat==0:
            lon=0
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lat==0 and i.lon==0:
          lat=30
          lon=90
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lat==180 and i.lon==180:
          lat=150
          lon=270
          temp=Location(lat,lon)
          new_state.append(temp)
        else:
          new_state.append(i)
  return new_state
            
def dec_lon90_270(cur_state):
  new_state=[]
  for i in cur_state:   
        if i.lon==90:
          lon=90
          lat=i.lat-30
          if lat==0:
            lon=0
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lon==270:
          lon=270
          lat=i.lat+30
          if lat==180:
            lon=180
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lat==0 and i.lon==0:
          lat=30
          lon=270
          temp=Location(lat,lon)
          new_state.append(temp)
        elif i.lat==180 and i.lon==180:
          lat=150
          lon=90
          temp=Location(lat,lon)
          new_state.append(temp)
        else:
          new_state.append(i)
  return new_state

class Node:
  state=None #list of Location type
  parent=None #Node Type
  action=None #str Type
  path_cost=list() #list of str Type
  h_eval_cost=None #int - heuristic cost
  level=None #what level in the graph

  def __init__(self, state, parent, action, h_eval_cost=None):
    self.state=state
    self.parent=parent
    self.action=action
    if self.parent is None:
      self.path_cost=[]
      self.path_cost.append(action)
      self.level=0
    else:
      self.path_cost=list(parent.path_cost)
      self.path_cost.append(action)
      self.level=parent.level+1
    if h_eval_cost is not None:
      self.h_eval_cost=self.level+h_eval_cost#for astar
    
  #def __eq__(self, other):
  #  if(self.state==other.state and self.h_eval_cost==other.h_eval_cost):
  #    return true
  #  else:
  #    return false
  
  def __cmp__(self, other):
        return cmp(self.h_eval_cost, other.h_eval_cost)
    
  def __lt__(self, other):
    return self.h_eval_cost<other.h_eval_cost
  
  def __key(self):
        return (self.state, self.parent, self.action, self.path_cost, self.h_eval_cost, self.level)

  def __hash__(self):
        return hash(self.__key())

  def __eq__(self, other):
        if isinstance(other, Node):
            return self.__key() == other.__key()
        return NotImplemented
      
  def __iter__(self):
       return NodeIterator(self)
      
class NodeIterator:
   def __init__(self, node):
      self._node = node
      self._index = 0
 
   def __next__(self):
    if self._index < len(self._node.state) :
      result = self._node.state[self._index]
      self._index +=1
      return result
    raise StopIteration

lat_lon_mapping={
    'Eq +30': inc_equator,
    'Eq -30': dec_equator,
    'Lon0/180 +30': inc_lon0_180,
    'Lon0/180 -30': dec_lon0_180,
    'Lon90/270 +30': inc_lon90_270,
    'Lon90/270 -30': dec_lon90_270,
}

lat_lon_opp_mapping={
    'Eq +30': 'Eq -30',
    'Eq -30': 'Eq +30',
    'Lon0/180 +30': 'Lon0/180 -30',
    'Lon0/180 -30': 'Lon0/180 +30',
    'Lon90/270 +30': 'Lon90/270 -30',
    'Lon90/270 -30': 'Lon90/270 +30',
}

import queue
class CheckableQueue(queue.Queue): # or OrderedSetQueue
    def __contains__(self, item):
        with self.mutex:
            return item in self.queue

import sys
import math
#import heapq
goal=[]
all_actions=set(lat_lon_mapping.keys())
frontier=None #queue object
explored=None #set object
solution=None #Node object
#heur='heuristicCost'
#new_n='newNodeGenerated'

def calcHeuristic(cur_state, goal_state):
  cost=0
  for i in range(len(cur_state)):
    print(i)
    temp1=abs(cur_state[i].lat-goal_state[i].lat)/30
    print(temp1)
    temp2=abs(cur_state[i].lon-goal_state[i].lon)/30
    print(temp2)
    if temp2==7:
      temp2=5
    if temp2==8:
      temp2=4
    if temp2==9:
      temp2=3
    if temp2==10:
      temp2=2
    if temp2==11:
      temp2=1
    temp=temp1+temp2
    print(temp)
    #if(goal_state[i].lat==90):
    #  temp=0.5*temp
    #elif(goal_state[i].lon==0 or goal_state[i].lon==180):
    #  temp=0.3*temp
    #elif(goal_state[i].lon==270 or goal_state[i].lon==90):
    #  temp=0.2*temp
    cost=cost+temp
    print(cost)
    print()
  #print(cost)
  #cost=math.ceil(cost/12)
  return cost

long_turn_cost={1:1,2:2,3:3,4:4,5:5,6:6,7:5,8:4,9:3,10:2,11:1,0:0}

def calcHeuristic2(cur_state, goal_state):
  cost=0
  temp1,temp2,temp3=[],[],[]
  for i in range(len(cur_state)):
    if goal_state[i].lat==90:
      lat=abs(cur_state[i].lat-goal_state[i].lat)/30
      lon=abs(cur_state[i].lon-goal_state[i].lon)/30
      #print(lon)
      lon=long_turn_cost.get(lon)
      #print(lon)
      temp1.append(lat+lon)
    if goal_state[i].lon==0 or goal_state[i].lon==180:
      lat=abs(cur_state[i].lat-goal_state[i].lat)/30
      lon=abs(cur_state[i].lon-goal_state[i].lon)/30
      #print(lon)
      lon=long_turn_cost.get(lon)
      #print(lon)
      temp2.append(lat+lon)
    if goal_state[i].lon==90 or goal_state[i].lon==270:
      lat=abs(cur_state[i].lat-goal_state[i].lat)/30
      lon=abs(cur_state[i].lon-goal_state[i].lon)/30
      #print(lon)
      lon=long_turn_cost.get(lon)
      #print(lon)
      temp3.append(lat+lon)
  #print(max(temp1))
  #print(max(temp2))
  #print(max(temp3))
  cost=max(temp1)+max(temp2)+max(temp3)
  #print(cost)
  #cost=math.ceil(cost/12)
  return cost

def getChildNodes(parent,algo):
  children=[]
  non_action={lat_lon_opp_mapping.get(parent.action)}
  perf_actions=all_actions-non_action
  
  for i in perf_actions:
    f=lat_lon_mapping.get(i)
    new_state=f(parent.state)
    if algo=='BFS':
      child=Node(new_state,parent,i)
    else:#Astar and #RBFS
      heur_cost=calcHeuristic2(new_state,goal)
      child=Node(new_state,parent,i,heur_cost)    
    children.append(child)
  return children

def bfs(root,algo):
  if(root.state==goal):
    return root
  frontier=CheckableQueue()
  frontier.queue.clear()
  frontier.put(root)
  explored=[]
  
  while(not frontier.empty()):
    node=frontier.get()
    explored.append(node.state)
    for child in getChildNodes(node,algo):
      if(child.state not in explored or child not in frontier):
        if(child.state==goal):
          return child,explored,frontier
        frontier.put(child)
  else:
    return None
  
def removeHighValue(node, frontier):
  for i in frontier:
    if(i.state==node.state):
      if(i.h_eval_cost>node.h_eval_cost):
        frontier.remove(i)
        frontier.append(node)
        return

f_limit=1000000
q_size=0
exp_bfs=0

def rbfs(root,algo):
  return rec_bfs(root,f_limit,algo)

def rec_bfs(node,f_limit,algo):
  if(node.state==goal):
    return node,0
  successors=[]
  global exp_bfs
  exp_bfs+=1
  for child in getChildNodes(node,algo):
    successors.append(child)
    global q_size
    q_size+=1
  if successors==[]:
    return None,1000000
  while(True):
    successors.sort(key=lambda x: x.h_eval_cost)
    best=successors[0]
    if(best.h_eval_cost>f_limit):
      return None,best.h_eval_cost
    alternative=successors[1].h_eval_cost
    result,best.h_eval_cost=rec_bfs(best,min(f_limit,alternative),algo)
    if result is not None:
      return result,0

def astar(root,algo):
  #frontier=queue.PriorityQueue()
  #frontier.queue.clear()
  frontier=[]
  #heapq.heappush(frontier,(0,root))
  #frontier.append({heur:0,new_n:root})
  #frontier.put(root)
  frontier.append(root)
  explored=[]
  
  while(len(frontier)>0):
    #node=frontier.get()
    #tup=heapq.heappop(frontier)
    #node=tup[1]
    
    #frontier=sorted(frontier, key = lambda i: i[heur])
    #print(frontier)
    #node_dict=frontier[0]
    #node=node_dict.get(new_n)
    #frontier.remove(node_dict)
    
    #print(len(frontier))
    frontier.sort(key=lambda x: x.h_eval_cost)
    node=frontier[0]
    #print(len(node.path_cost)-1)
    frontier.remove(node)
    #print(node.h_eval_cost)
    if(node.state==goal):
      return node,explored,frontier
    explored.append(node.state)
    for child in getChildNodes(node,algo):
      #print(child.h_eval_cost)
      if(child.state not in explored or child not in frontier):
        #frontier.put(child)
        #heapq.heappush(frontier,(child.h_eval_cost,child))
        #frontier.append({heur:child.h_eval_cost,new_n:child})
        #frontier = [dict(tupleized) for tupleized in set(tuple(item.items()) for item in frontier)]
        frontier.append(child)
      else:
        removeHighValue(child, frontier)
        
  else:
    return None

def getProblemState(file_name):
    file = open(file_name, "r")
    state = []
    for line in file:
      if(line.startswith('<')):
        continue
      end=line.find(',')

      line=line[(end+1):]
      start=line.find('(')
      mid=line.find(',')
      end=line.find(')')
      lat=int(line[(start+1):mid])
      lon=int(line[(mid+1):end])
      cur_loc=Location(lat,lon)
      state.append(cur_loc)

      line=line[(end+2):]
      start=line.find('(')
      mid=line.find(',')
      end=line.find(')')
      lat=int(line[(start+1):mid])
      lon=int(line[(mid+1):end])
      goal_loc=Location(lat,lon)
      goal.append(goal_loc)
    return state
      
def main():
  args=sys.argv
  algo=args[1]
  #algo='RBFS'
  input_filename=args[2]
  #input_filename="PathN-8.mb"
  
  initial=getProblemState(input_filename)
  root=Node(initial,None,'start')
  
  if(algo=='BFS'):
    solution,explored,frontier=bfs(root,algo)
  elif(algo=='AStar'):
    solution,explored,frontier=astar(root,algo)
  elif(algo=='RBFS'):
    solution=rbfs(root,algo)[0]
  
  if(solution is None):
    print('No Solution found')
  else:
    if(algo=='RBFS'):
      print('No of states expanded: {}'.format(exp_bfs))
      print('Maximum size of queue: {}'.format(q_size))
      print('Final path length: {}'.format(len(solution.path_cost)-1))
      print('Final path sequence: {}'.format(solution.path_cost))
    else:
      print('No of states expanded: {}'.format(len(explored)))
      if(isinstance(frontier,list)):
        print('Maximum size of queue: {}'.format(len(frontier)))
      else:
        print('Maximum size of queue: {}'.format(frontier.qsize()))
      print('Final path length: {}'.format(len(solution.path_cost)-1))
      print('Final path sequence: {}'.format(solution.path_cost))
    
main()